-html_options = {:class => 'sel80 medium input_cleanse', :tabindex => 2}
.top
  .filter
    = form_for :filter, :url => @action_url, :html => { :method => :post, :class => :form, :id => 'monitoring_filter' } do |f|
      .column
        = render 'server_status'
        = hidden_field_tag :servertime, Time.now.utc.to_i
        .reloader
          = label_tag :autoreload do
            = check_box_tag :autoreload, true, true
            = t 'layout.autoreload_page'
      .column
        - if current_user
          .bordered.nopadding
            %h3.medium= t("layout.build_lists.ownership.header")
            =f.hidden_field :ownership
            .btn-group
              - ownerships = %w[owned everything]
              - ownerships << 'related' unless @project
              - ownerships.each do |ownership|
                -options = {:class => @filter.ownership == ownership ? 'active' : '', :value => ownership, :style => (@project ? 'width:50%;' : '')}
                %button.btn.ownership{options}= t "layout.build_lists.ownership.#{ownership}"
        %h3.medium= t 'number_rows'
        =hidden_field_tag :per_page, @per_page
        .btn-group
          -BuildList::Filter::PER_PAGE.each do |num|
            %button.btn.per_page{:value => num, :class => @per_page == num ? 'active' : ''}=num
        %h3.medium= t 'activerecord.attributes.build_list.status'
        .lineForm.aside
          = f.select :status, BuildList::STATUSES.collect{|status| [BuildList.human_status(status), status]}, {:include_blank => true, :selected => @filter.status},
            html_options.merge(:id => 'status')
        .both
        %br/
      .column
        %h3.medium= t 'activerecord.models.platform'
        .lineForm.aside
          = f.select :platform_id, Platform.main.collect{|pl| [pl.name, pl.id]}, {:include_blank => true, :selected => @filter.platform_id}, html_options.merge(:id => 'platform')
        %h3.medium= t 'activerecord.attributes.build_list.arch'
        .lineForm.aside
          = f.select :arch_id, Arch.recent.collect{|arch| [arch.name, arch.id]}, {:include_blank => true, :selected => @filter.arch_id}, html_options.merge(:id => 'architecture')
        %h3.medium= t 'activerecord.models.mass_build'
        .lineForm.aside
          = f.select :mass_build_id, options_from_collection_for_select( MassBuild.all, :id, :name, @filter.mass_build_id ), {:include_blank => true, :selected => @filter.mass_build_id},
            html_options.merge(:id => 'mass_build')

      .column
        .floatleft
          %h3.medium= t '_on'
          -date = @filter.updated_at_start ? @filter.updated_at_start.strftime('%d/%m/%Y') : nil
          =f.text_field :updated_at_start, :readonly => "readonly", :size => 10, :class => 'mediumheight min input_cleanse', :value => date
          =link_to image_tag('x.png', :alt => 'x', :class => 'semi'), '#filter_updated_at_start', :id => 'updated_at_clear'
        .floatright
          %h3.medium= t 'until'
          -date = @filter.updated_at_end ? @filter.updated_at_end.strftime('%d/%m/%Y') : nil
          =f.text_field :updated_at_end, :readonly => "readonly", :size => 10, :class => 'mediumheight min input_cleanse', :value => date
          =link_to image_tag('x.png', :alt => 'x', :class => 'semi'), '#filter_updated_at_end', :id => 'updated_at_clear'
        .both
        %h3.medium= t 'layout.build_lists.project_name_search'
        %input#filter_project_name.mediumheight.input_cleanse{:name => "filter[project_name]", :size => "30", :type => "text"}/
        %h3.medium= t 'layout.build_lists.bs_id_search'
        %input#filter_bs_id.mediumheight.input_cleanse{:name => "filter[bs_id]", :size => "30", :type => "text"}/
        %br/
        %br/
      .butgrp
        -if @project and can?(:create, @project.build_lists.build)
          %input{:type => 'button', :onclick => "location.href='#{new_project_build_list_path(@project)}'", :value => t('layout.build_lists.new_header')}
        = f.submit t('layout.search.header')
        = f.submit t('reset'), :id => 'filter_clear'
      .both
    .both
  .switch
    %a{:href => "#"}= t 'layout.build_lists.hide_filter'
:javascript
  var MONITORING_FILTER_HIDE = "monitoring_filter_hide";
  $(".switch").toggle(
    function () {
      var d = new Date();
      d.setMonth(d.getMonth() + 1);
      $(".filter").hide("slow");
      $(".switch a").text("#{t 'layout.build_lists.show_filter'}");
      setCookie(MONITORING_FILTER_HIDE, 'true', d);
    },
    function () {
      $(".filter").show("slow");
      $(".switch a").text("#{t 'layout.build_lists.hide_filter'}");
      var d = new Date();
      d.setMonth(d.getMonth() + 1);
      setCookie(MONITORING_FILTER_HIDE, 'false', d);
    }
  );
  #{cookies[:monitoring_filter_hide] == 'true' ? "$('.switch').click();" : ''}
  #{if I18n.locale == :ru
        "$.datepicker.regional['ru'] = {
          closeText: 'Закрыть',
          prevText: '<Пред',
          nextText: 'След>',
          currentText:  'Сейчас',
          monthNames: ['Январь','Февраль','Март','Апрель','Май','Июнь',
          'Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь'],
          monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
          'Июл','Авг','Сен','Окт','Ноя','Дек'],
          dayNames: ['воскресенье','понедельник','вторник','среда','четверг','пятница','суббота'],
          dayNamesShort: ['вск','пнд','втр','срд','чтв','птн','сбт'],
          dayNamesMin: ['Вс','Пн','Вт','Ср','Чт','Пт','Сб'],
          weekHeader: 'Не',
          dateFormat: 'dd/mm/yy',
          firstDay: 1,
          isRTL: false,
          showMonthAfterYear: false,
          yearSuffix: '',
          //showTimezone: true
        };
        $.datepicker.setDefaults($.datepicker.regional['ru']);"
      end
     }
