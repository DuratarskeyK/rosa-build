RosaABF.controller('NewBuildListController', ['$scope', '$http', '$timeout', '$window',
  function($scope, $http, $timeout, $window) {

  $scope.save_to_repository_id = null;
  $scope.extra_repositories = {};
  $scope.extra_build_lists  = {};

  var save_to_repository     = $('#build_list_save_to_repository_id');
  var all_repositories       = $('.all_platforms input');
  var auto_create_container  = $('#build_list_auto_create_container');
  var extra_repos            = $('.autocomplete-form.extra_repositories');
  var build_list_auto_publish_status = $('#build_list_auto_publish_status');
  var bl_version_sel         = $('#build_list_project_version');
  var all_platforms_name     = $('h4.build_for_pl');
  var build_for_platform_id  = null;
  var build_platform         = null;

  $scope.init = function(pl_id, save_to_repository_id) {
    build_for_platform_id        = pl_id;
    build_platform = $('#build_for_pl_' + pl_id);
    $scope.save_to_repository_id = save_to_repository_id;
  }

  $scope.needHidePlatform = function(pl_id) {
    if (build_platform.size() > 0 && build_for_platform_id !== pl_id) {
      return true;
    }
    else {
      return false;
    }
  }

  $scope.change_save_to_repository = function() {

    var selected_option = save_to_repository.find('option:selected');
    var rep_name = selected_option.text().match(/[\w-]+\/([\w-]+)/)[1];

    build_for_platform_id = selected_option.attr('platform_id');
    build_platform = $('#build_for_pl_' + build_for_platform_id);

    all_repositories.prop('checked', null);

    updateExtraReposAndBuildLists(build_for_platform_id);
    updatedDefaultArches(selected_option);
    $('.autocomplete-form table tbody').empty();
    if (build_platform.size() == 0) {
      all_repositories.prop('disabled', null);
      auto_create_container.prop('checked', null);
      addPersonalPlatformToExtraRepos(selected_option, extra_repos);
      extra_repos.show();
    } else {
      all_repositories.prop('disabled', 'disabled');
      extra_repos.hide();
      //var parent = build_platform.parent();
      build_platform.find('input').prop('disabled', null);
      build_platform.find('input[rep_name="main"]').prop('checked', 'checked');
      if (rep_name != 'main') {
        build_platform.find('input[rep_name="' + rep_name + '"]').prop('checked', 'checked');
      }
      setBranchSelected(selected_option);
      var tmp = build_platform.find('input[rep_name="main"]');
      tmp = build_platform.find('input[rep_name="' + rep_name + '"]');
    }

    if (selected_option.attr('publish_without_qa') == '1') {
      build_list_auto_publish_status.prop('disabled', null).val('default');
    } else {
      build_list_auto_publish_status.val('none').prop('disabled', 'disabled');
      auto_create_container.prop('checked', 'checked');
    }
  }

  function updatedDefaultArches(selected_option) {
    $('input[name="arches[]"]').prop('checked', null);
    _.each(selected_option.attr('default_arches').split(' '), function(id){
      $('#arches_' + id).prop('checked', 'checked');
    });
  }

  function updateExtraReposAndBuildLists(save_to_platform_id) {
    $.each($('.autocomplete-form'), function() {
      var form = $(this);
      var path = form.attr('path') + '?platform_id=' + save_to_platform_id;
      form.find('.autocomplete').attr('data-autocomplete', path);
    });
  }

  function addPersonalPlatformToExtraRepos(selected_option, extra_repos) {
    var default_value = extra_repos.find('div[label="' + selected_option.text() + '"]');
    if (default_value.length == 0) { return; }
    addDataToAutocompleteForm(
      extra_repos,
      default_value.attr('path'),
      default_value.attr('label'),
      default_value.attr('name'),
      default_value.attr('value')
    );
  }

  function setBranchSelected(selected_option) {
    var pl_name = selected_option.text().match(/([\w-.]+)\/[\w-.]+/)[1];

    var branch_pl_opt = bl_version_sel.find('option[value="' + pl_name + '"]');
    // If there is branch we need - set it selected:
    if (branch_pl_opt.size() > 0) {
      bl_version_sel.find('option[selected]').prop('selected', null);
      branch_pl_opt.prop('selected', 'selected');
      bl_version_sel.val(branch_pl_opt);
      // hack for FF to force render of select box.
      bl_version_sel[0].innerHTML = bl_version_sel[0].innerHTML;
    }
  }

  $scope.get_extra_repositories = function(val) {
    return $http.get('http://maps.googleapis.com/maps/api/geocode/json', {
      params: {
        address: val,
        sensor: false
      }
    }).then(function(res){
      var addresses = [];
      angular.forEach(res.data.results, function(item){
        addresses.push(item.formatted_address);
      });
      return addresses;
    });
  }

  $scope.select_extra_repositories = function(item, model, label) {

  }
}]);
