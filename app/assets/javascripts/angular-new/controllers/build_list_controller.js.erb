RosaABF.controller('BuildListController', ['$scope', '$http', '$timeout', 'SoundNotificationsHelper', function($scope, $http, $timeout, SoundNotificationsHelper) {

  $scope.advisoriable_types = <%=BuildList::RELEASE_UPDATE_TYPES%>;

  $scope.id                  = $('#build_list_id').val();
  $scope.build_list          = null;
  $scope.subject             = {}; // See: shared/build_results
  $scope.attach_advisory     = 'no';
  // Statuses: advisory_not_found, server_error, continue_input
  $scope.search_status       = 'continue_input';
  $scope.term                = '';
  $scope.advisory            = null;
  $scope.update_type_errors  = null;
  $scope.isOpenLog           = false;
  $scope.log_reload_interval = 10000;
  $scope.log_autoreload      = true;
  $scope.log_refresh_fn      = null;
  $scope.build_log           = null;
  var log_path               = Routes.log_build_list_path($scope.id, {format: 'json'});

  $scope.getBuildList = function() {
    $http.get(Routes.build_list_path($scope.id, {format: 'json'})).success(function(results) {
      var build_list = new BuildList(results.build_list);
      if ($scope.build_list && $scope.build_list.status != build_list.status)
        SoundNotificationsHelper.buildStatusChanged();
      $scope.build_list = $scope.subject = build_list;
    });
  }

  $scope.cancelRefresh = null;
  $scope.refresh = function() {
    if ( $scope.attach_advisory == 'no' &&
          (
            !$scope.build_list ||
            !(
              $scope.build_list.status == <%=BuildList::BUILD_PUBLISHED%> ||
              $scope.build_list.status == <%=BuildList::REJECTED_PUBLISH%> ||
              $scope.build_list.status == <%=BuildList::FAILED_PUBLISH%> ||
              $scope.build_list.status == <%=BuildList::BUILD_CANCELED%> ||
              $scope.build_list.status == <%=BuildList::BUILD_ERROR%>
            )
          )
      ) {
      $scope.getBuildList();
    }
    $scope.cancelRefresh = $timeout($scope.refresh, 10000);
  }
  $scope.refresh();

  $scope.search = function() {
    var params = {query: $scope.term, bl_type: $scope.build_list.update_type, format: 'json'};
    $http.get(Routes.search_advisories_path(params)).success(function(results) {
        $scope.search_status    = 'continue_input';
        $scope.advisory         = results;
        $('#attach_advisory').find('.advisory_id').val($scope.advisory.advisory_id);
      }).error(function(data, status, headers, config) {
        $scope.search_status  = status == 404 ? 'advisory_not_found' : 'server_error';
        $scope.advisory       = null;
        $('#attach_advisory').find('.advisory_id').val('');
      });;

  }

  $scope.updateTypeChanged = function() {
    if (_.contains($scope.advisoriable_types, $scope.build_list.update_type)) {
      if ($scope.advisory || $scope.term.length > 0) { $scope.search(); }
    } else {
      $scope.attach_advisory = 'no';
    }
    $scope.updateUpdateType();
  }

  $scope.attachAdvisoryChanged = function() {
    if (!_.contains($scope.advisoriable_types, $scope.build_list.update_type)) {
      $scope.build_list.update_type = $scope.advisoriable_types[0];
      $scope.updateUpdateType();
    }
    $('#build_list_update_type .nonadvisoriable').attr('disabled', ($scope.attach_advisory != 'no'));
  }

  $scope.updateUpdateType = function() {
    $http.put(
      Routes.update_type_build_list_path($scope.id),
      {update_type: $scope.build_list.update_type, format: 'json'}
      ).success(function(results) {
        $scope.update_type_errors = null;
        $timeout(function() {
          $('#build_list_update_type').effect('highlight', {}, 1000);
        }, 100);
      }).error(function(data, status, headers, config) {
        $scope.update_type_errors = data.message;
      });
  }

  $scope.getLog = function() {
    $http.get(log_path).success(function(results) {
      $scope.build_log = results.log;
      if(!results.building) { $scope.log_autoreload = false }
    });
    $scope.log_refresh_fn = $timeout($scope.getLog, $scope.log_reload_interval);
  }

  $scope.updateLogRefresh = function() {
    if($scope.log_refresh_fn) {
      $timeout.cancel($scope.log_refresh_fn);
    }

    if($scope.isOpenLog && $scope.log_autoreload) {
      $scope.getLog();
    };
  }

  $scope.$watch('isOpenLog', function(){
      $scope.updateLogRefresh();
  }, true);

  $scope.change_log_autoreload = function($event) {
    $scope.log_autoreload = $event;
    $scope.updateLogRefresh();
  }

  $scope.change_log_interval = function($event) {
    $scope.log_reload_interval = $event;
    $scope.updateLogRefresh();
  }
}]);
